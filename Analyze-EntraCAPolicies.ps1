<#
.SYNOPSIS
Analyzes Entra ID Conditional Access policies from a JSON export file against a set of security best practices.

.DESCRIPTION
Reads Conditional Access policy data exported by Get-EntraConditionalAccessPolicies.ps1 (in JSON format).
Performs several checks based on common Microsoft security recommendations (e.g., blocking legacy auth, MFA for admins, high-risk sign-in handling).
Assigns a severity level to non-compliant findings.
Calculates an overall compliance score based on the implemented checks.
Outputs the detailed assessment results to a CSV file for review and reporting.

.NOTES
Version:        1.0
Author:         AndrÃ© Motta - CSA Security - France
Date:           2025-04-29
Input:          Requires a JSON file generated by Get-EntraConditionalAccessPolicies.ps1 -OutputFormat JSON.
Output:         Generates a CSV report detailing the assessment findings.
Dependencies:   PowerShell 5.1+

.LINK
Based on recommendations like those found at:
https://learn.microsoft.com/en-us/entra/architecture/secure-best-practices
https://learn.microsoft.com/en-us/entra/identity/conditional-access/concept-conditional-access-policy-common

.PARAMETER JsonInputPath
Path to the JSON file containing the Conditional Access policy data exported from Get-EntraConditionalAccessPolicies.ps1.

.PARAMETER CsvOutputPath
Path where the assessment results CSV file will be saved.

.EXAMPLE
.\Analyze-EntraCAPolicies.ps1 -JsonInputPath "C:\Exports\CAPolicies.json" -CsvOutputPath "C:\Reports\CA_Assessment.csv"
# Analyzes the policies from CAPolicies.json and saves the report to CA_Assessment.csv

.EXAMPLE
.\Analyze-EntraCAPolicies.ps1 -JsonInputPath .\policies.json -CsvOutputPath .\assessment_report.csv
# Uses files in the current directory for input and output.
#>
param(
    [Parameter(Mandatory=$true)]
    [string]$JsonInputPath,

    [Parameter(Mandatory=$true)]
    [string]$CsvOutputPath
)

# --- Configuration: Define Best Practice Checks and Admin Roles ---

# Define the checks to be performed
# Each check function should return an object with: Status ('Compliant', 'Non-Compliant', 'Not Applicable', 'Error'), Severity ('High', 'Medium', 'Low', 'Informational'), Finding (string), Recommendation (string)
$ChecksToRun = @(
    'Test-LegacyAuthBlocked'
    'Test-AdminMfaRequired'
    'Test-HighRiskSignInPolicy'
    'Test-AllUserMfaPolicy'
    'Test-RiskyUserPolicy'
    'Test-TermsOfUseForGuests' # Example of another potential check
)

# Define key administrative role Template IDs (GUIDs) - Add more as needed
# Find IDs: Get-MgDirectoryRoleTemplate | Select Id, DisplayName
$AdminRoleIds = @{
    'Global Administrator' = '62e90394-69f5-4237-9190-012177145e10'
    'Security Administrator' = '194ae4cb-b126-40b2-bd5b-6091b380977d'
    'Conditional Access Administrator' = 'b1be1c3e-b658-4f43-b4c0-f296ce3a8a76'
    'Exchange Administrator' = '29232cdf-9323-42fd-ade2-1d097af3e4de'
    'SharePoint Administrator' = 'f2afa96b-3ddd-4375-a48c-acc73cf01204'
    # Add other privileged roles as required by your organization's standards
}
$AdminRoleGuids = $AdminRoleIds.Values

# --- Helper Functions ---

# Function to safely get property value from a PSObject (case-insensitive)
function Get-SafePropertyValue {
    param($PSObject, $PropertyName)
    if ($null -ne $PSObject -and $null -ne $PSObject.PSObject.Properties[$PropertyName]) {
        return $PSObject.PSObject.Properties[$PropertyName].Value
    }
    return $null
}

# --- Best Practice Check Functions ---

function Test-LegacyAuthBlocked {
    param([array]$Policies)
    $Result = @{ CheckName = 'Block Legacy Authentication'; Status = 'Non-Compliant'; Severity = 'High'; Finding = 'No enabled policy found explicitly blocking legacy authentication (Client App Types: Other).'; Recommendation = 'Implement a Conditional Access policy targeting "Other clients" (legacy authentication) for all users and granting "Block access". Ensure necessary exclusions are minimal and justified.' }

    # Find enabled policies targeting 'other' client apps
    $LegacyAuthPolicies = $Policies | Where-Object {
        $state = Get-SafePropertyValue $_ 'State'
        $clientApps = Get-SafePropertyValue $_ 'ClientAppTypes'
        $state -eq 'enabled' -and $null -ne $clientApps -and $clientApps -contains 'other'
    }

    if ($LegacyAuthPolicies.Count -eq 0) {
        $Result.Finding = 'No enabled policy found targeting legacy authentication clients (Client App Types: Other).'
        return $Result # Non-Compliant
    }

    # Check if any of these policies explicitly block access
    $BlockingLegacyPolicy = $LegacyAuthPolicies | Where-Object {
        $grantOperator = Get-SafePropertyValue $_ 'GrantControlsOperator'
        $grantControls = Get-SafePropertyValue $_ 'GrantRequiredControls'
        $grantOperator -eq 'Block' -or ($null -ne $grantControls -and $grantControls -contains 'block')
    }

    if ($BlockingLegacyPolicy) {
        $Result.Status = 'Compliant'
        $Result.Severity = 'Informational'
        $Result.Finding = "At least one enabled policy ($($BlockingLegacyPolicy[0].DisplayName)) appears to block legacy authentication."
        $Result.Recommendation = "Ensure the blocking policy covers all required users and applications, with minimal necessary exclusions."
    } else {
        $Result.Finding = "Enabled policies target legacy authentication clients, but none explicitly grant 'Block access'."
        $Result.Recommendation = "Review policies targeting 'Other clients'. Ensure at least one effectively blocks access for the intended scope."
    }

    return $Result
}

function Test-AdminMfaRequired {
    param([array]$Policies, [array]$AdminRoleGuidsToCheck)
    $Result = @{ CheckName = 'MFA for Administrators'; Status = 'Non-Compliant'; Severity = 'High'; Finding = 'No enabled policy found requiring MFA for key administrative roles.'; Recommendation = 'Implement a Conditional Access policy targeting administrative roles and requiring multifactor authentication (MFA) grant control.' }

    # Find enabled policies targeting any of the specified admin roles and requiring MFA
    $AdminMfaPolicy = $Policies | Where-Object {
        $state = Get-SafePropertyValue $_ 'State'
        $includeRoles = Get-SafePropertyValue $_ 'IncludeRoles' # This contains resolved names/IDs or just IDs depending on source script run
        $grantControls = Get-SafePropertyValue $_ 'GrantRequiredControls'

        # Check if state is enabled, grant control includes MFA, and includes at least one admin role
        $targetsAdminRole = $false
        if ($null -ne $includeRoles) {
            foreach ($role in $includeRoles) {
                # Check if the role string contains any of the admin GUIDs
                if ($AdminRoleGuidsToCheck | Where-Object { $role -match $_ }) {
                    $targetsAdminRole = $true
                    break
                }
            }
        }

        $state -eq 'enabled' -and $null -ne $grantControls -and $grantControls -contains 'mfa' -and $targetsAdminRole
    }

    if ($AdminMfaPolicy) {
        $Result.Status = 'Compliant'
        $Result.Severity = 'Informational'
        $Result.Finding = "At least one enabled policy ($($AdminMfaPolicy[0].DisplayName)) targets administrative roles and requires MFA."
        $Result.Recommendation = "Ensure the policy covers all necessary administrative roles and users, with minimal justified exclusions (e.g., break-glass accounts excluded via group)."
    }
    # Note: This check doesn't deeply analyze exclusions within the identified policy or conflicting policies.

    return $Result
}

function Test-HighRiskSignInPolicy {
    param([array]$Policies)
    $Result = @{ CheckName = 'High-Risk Sign-ins'; Status = 'Non-Compliant'; Severity = 'High'; Finding = 'No enabled policy found explicitly blocking or requiring MFA for High sign-in risk.'; Recommendation = 'Implement a Conditional Access policy targeting all users, triggering on High sign-in risk level, and granting "Block access" or "Require multifactor authentication".' }

    # Find enabled policies targeting High sign-in risk
    $HighRiskPolicies = $Policies | Where-Object {
        $state = Get-SafePropertyValue $_ 'State'
        $signInRisk = Get-SafePropertyValue $_ 'SignInRiskLevels'
        $state -eq 'enabled' -and $null -ne $signInRisk -and $signInRisk -contains 'high'
    }

     if ($HighRiskPolicies.Count -eq 0) {
        $Result.Finding = 'No enabled policy found targeting High sign-in risk level.'
        return $Result # Non-Compliant
    }

    # Check if any of these policies block or require MFA
    $EffectiveHighRiskPolicy = $HighRiskPolicies | Where-Object {
        $grantOperator = Get-SafePropertyValue $_ 'GrantControlsOperator'
        $grantControls = Get-SafePropertyValue $_ 'GrantRequiredControls'
        $grantOperator -eq 'Block' -or ($null -ne $grantControls -and ($grantControls -contains 'block' -or $grantControls -contains 'mfa'))
    }

    if ($EffectiveHighRiskPolicy) {
        $controlType = "Block/MFA" # Default
        if ($EffectiveHighRiskPolicy[0].GrantControlsOperator -eq 'Block' -or (Get-SafePropertyValue $EffectiveHighRiskPolicy[0] 'GrantRequiredControls' -contains 'block')) {
            $controlType = "Block"
        } elseif (Get-SafePropertyValue $EffectiveHighRiskPolicy[0] 'GrantRequiredControls' -contains 'mfa') {
            $controlType = "MFA"
        }

        $Result.Status = 'Compliant'
        $Result.Severity = 'Informational'
        $Result.Finding = "At least one enabled policy ($($EffectiveHighRiskPolicy[0].DisplayName)) targets High sign-in risk and requires $controlType."
        $Result.Recommendation = "Ensure the policy covers all users with minimal exclusions. Consider separate policies for different risk levels (Medium, Low) if needed."
    } else {
         $Result.Finding = "Enabled policies target High sign-in risk, but none explicitly require Block or MFA grant controls."
         $Result.Recommendation = "Review policies targeting High sign-in risk. Ensure at least one requires Block or MFA for the intended scope."
    }
    return $Result
}

function Test-AllUserMfaPolicy {
     param([array]$Policies)
     $Result = @{ CheckName = 'Baseline MFA for All Users'; Status = 'Non-Compliant'; Severity = 'Medium'; Finding = 'No single enabled policy found targeting "All Users" and requiring MFA.'; Recommendation = 'Consider implementing a baseline Conditional Access policy targeting "All Users" (with appropriate exclusions for break-glass accounts, service accounts, etc.) and requiring MFA.' }

     # Find enabled policies targeting 'All Users' (or equivalent representation in JSON) and requiring MFA
     $AllUserMfaPolicy = $Policies | Where-Object {
        $state = Get-SafePropertyValue $_ 'State'
        # Check how 'All Users' is represented. In the source script, it might be an empty IncludeUsers/Groups/Roles array, or specific values.
        # Assuming the JSON export represents 'All Users' by having 'All' in IncludeUsers or similar. Adjust if needed based on actual JSON structure.
        $includeUsers = Get-SafePropertyValue $_ 'IncludeUsers'
        $targetsAllUsers = $false
        if ($null -ne $includeUsers -and $includeUsers -contains 'All') { # Check if 'All' literal exists
             $targetsAllUsers = $true
        } elseif ($null -eq $includeUsers -and $null -eq (Get-SafePropertyValue $_ 'IncludeGroups') -and $null -eq (Get-SafePropertyValue $_ 'IncludeRoles')) {
            # Alternative check: If Include Users/Groups/Roles are all empty/null, it might imply 'All Users' in some contexts (less reliable)
            # This part needs validation against the actual JSON output structure for 'All Users' policies.
            # For now, primarily relying on the 'All' literal string.
        }

        $grantControls = Get-SafePropertyValue $_ 'GrantRequiredControls'

        $state -eq 'enabled' -and $targetsAllUsers -and $null -ne $grantControls -and $grantControls -contains 'mfa'
     }

    if ($AllUserMfaPolicy) {
        $Result.Status = 'Compliant'
        $Result.Severity = 'Informational'
        $Result.Finding = "At least one enabled policy ($($AllUserMfaPolicy[0].DisplayName)) appears to target 'All Users' and require MFA."
        $Result.Recommendation = "Review the policy's exclusions carefully to ensure break-glass accounts, service principals, and other necessary exceptions are correctly configured."
    } else {
        # Add a nuance: Maybe MFA is achieved through multiple policies? This check is basic.
         $Result.Finding += " Note: MFA might be enforced through multiple targeted policies rather than a single 'All Users' policy. This check looks for a specific 'All Users' MFA policy."
    }
    return $Result
}

function Test-RiskyUserPolicy {
    param([array]$Policies)
    $Result = @{ CheckName = 'High-Risk Users'; Status = 'Non-Compliant'; Severity = 'High'; Finding = 'No enabled policy found explicitly requiring password change or blocking access for High user risk.'; Recommendation = 'Implement a Conditional Access policy targeting all users, triggering on High user risk level, and granting "Require password change" or "Block access".' }

    # Find enabled policies targeting High user risk
    $HighRiskUserPolicies = $Policies | Where-Object {
        $state = Get-SafePropertyValue $_ 'State'
        $userRisk = Get-SafePropertyValue $_ 'UserRiskLevels'
        $state -eq 'enabled' -and $null -ne $userRisk -and $userRisk -contains 'high'
    }

     if ($HighRiskUserPolicies.Count -eq 0) {
        $Result.Finding = 'No enabled policy found targeting High user risk level.'
        return $Result # Non-Compliant
    }

    # Check if any of these policies block or require password change
    $EffectiveHighRiskUserPolicy = $HighRiskUserPolicies | Where-Object {
        $grantOperator = Get-SafePropertyValue $_ 'GrantControlsOperator'
        $grantControls = Get-SafePropertyValue $_ 'GrantRequiredControls'
        $grantOperator -eq 'Block' -or ($null -ne $grantControls -and ($grantControls -contains 'block' -or $grantControls -contains 'passwordChange')) # Check for passwordChange control
    }

    if ($EffectiveHighRiskUserPolicy) {
        $controlType = "Block/PasswordChange" # Default
        if ($EffectiveHighRiskUserPolicy[0].GrantControlsOperator -eq 'Block' -or (Get-SafePropertyValue $EffectiveHighRiskUserPolicy[0] 'GrantRequiredControls' -contains 'block')) {
            $controlType = "Block"
        } elseif (Get-SafePropertyValue $EffectiveHighRiskUserPolicy[0] 'GrantRequiredControls' -contains 'passwordChange') {
            $controlType = "Password Change"
        }

        $Result.Status = 'Compliant'
        $Result.Severity = 'Informational'
        $Result.Finding = "At least one enabled policy ($($EffectiveHighRiskUserPolicy[0].DisplayName)) targets High user risk and requires $controlType."
        $Result.Recommendation = "Ensure the policy covers all users with minimal exclusions. Consider user experience for password change requirements."
    } else {
         $Result.Finding = "Enabled policies target High user risk, but none explicitly require Block or Password Change grant controls."
         $Result.Recommendation = "Review policies targeting High user risk. Ensure at least one requires Block or Password Change for the intended scope."
    }
    return $Result
}

function Test-TermsOfUseForGuests {
     param([array]$Policies)
     $Result = @{ CheckName = 'Terms of Use for Guests'; Status = 'Not Applicable'; Severity = 'Low'; Finding = 'No enabled policy found requiring Terms of Use specifically for Guest users.'; Recommendation = 'If guest collaboration is significant, consider implementing a policy requiring Guest users (or specific types) to accept Terms of Use upon accessing certain resources.' }

     # Find enabled policies targeting Guests and requiring Terms of Use
     $GuestToUPolicy = $Policies | Where-Object {
        $state = Get-SafePropertyValue $_ 'State'
        $includeGuests = Get-SafePropertyValue $_ 'IncludeGuestOrExternalUserTypes' # Check if Guests are included
        $grantTerms = Get-SafePropertyValue $_ 'GrantTermsOfUse' # Check if ToU is required

        $state -eq 'enabled' -and $null -ne $includeGuests -and ($includeGuests -match 'guest' -or $includeGuests -match 'external') -and $null -ne $grantTerms -and $grantTerms.Count -gt 0
     }

    if ($GuestToUPolicy) {
        $Result.Status = 'Compliant'
        $Result.Severity = 'Informational'
        $Result.Finding = "At least one enabled policy ($($GuestToUPolicy[0].DisplayName)) appears to target Guest/External users and require Terms of Use."
        $Result.Recommendation = "Ensure the Terms of Use policy targets the correct guest types and resources as per your governance requirements."
    } else {
        # This is often optional, so default status is Not Applicable unless actively desired
        $Result.Status = 'Non-Compliant' # Change to Non-Compliant if ToU for Guests is a desired standard
        $Result.Severity = 'Low'
    }
    return $Result
}


# --- Main Script Logic ---

Write-Host "Starting Conditional Access Policy Assessment..."

# Validate Input Path
if (-not (Test-Path -Path $JsonInputPath -PathType Leaf)) {
    Write-Error "Input JSON file not found: $JsonInputPath"
    return
}

# Load and Parse JSON Data
Write-Host "Loading policies from: $JsonInputPath"
try {
    $PolicyData = Get-Content -Path $JsonInputPath -Raw | ConvertFrom-Json -ErrorAction Stop
}
catch {
    Write-Error "Failed to read or parse JSON file: $JsonInputPath. Ensure it's a valid JSON export from Get-EntraConditionalAccessPolicies.ps1. Error: $($_.Exception.Message)"
    return
}

if ($null -eq $PolicyData -or $PolicyData.Count -eq 0) {
    Write-Warning "JSON file loaded, but it contains no policy data."
    return
}

Write-Host "Successfully loaded $($PolicyData.Count) policies."

# Run Assessments
$AssessmentResults = [System.Collections.Generic.List[PSObject]]::new()
Write-Host "Running assessment checks..."

foreach ($checkName in $ChecksToRun) {
    Write-Host " - Running check: $checkName"
    try {
        # Dynamically call the function
        $checkFunction = Get-Command $checkName -ErrorAction Stop
        # Pass necessary parameters (e.g., policy data, admin roles)
        if ($checkName -eq 'Test-AdminMfaRequired') {
             $result = & $checkFunction -Policies $PolicyData -AdminRoleGuidsToCheck $AdminRoleGuids
        } else {
             $result = & $checkFunction -Policies $PolicyData
        }

        # Add the check name to the result object explicitly if the function didn't
        if ($null -eq (Get-SafePropertyValue $result 'CheckName')) {
            $result.CheckName = $checkName.Replace('Test-','') # Add formatted name
        }

        $AssessmentResults.Add([PSCustomObject]$result)
    }
    catch {
        Write-Warning "Failed to execute check '$checkName'. Error: $($_.Exception.Message)"
        $AssessmentResults.Add([PSCustomObject]@{
            CheckName = $checkName.Replace('Test-','')
            Status = 'Error'
            Severity = 'N/A'
            Finding = "Could not execute check function. Error: $($_.Exception.Message)"
            Recommendation = "Verify script integrity and function definition."
        })
    }
}

# Calculate Score
$TotalChecks = $AssessmentResults.Count
$CompliantChecks = ($AssessmentResults | Where-Object { $_.Status -eq 'Compliant' }).Count
$NonCompliantChecks = ($AssessmentResults | Where-Object { $_.Status -eq 'Non-Compliant' }).Count
$ErrorChecks = ($AssessmentResults | Where-Object { $_.Status -eq 'Error' }).Count
$NotApplicableChecks = ($AssessmentResults | Where-Object { $_.Status -eq 'Not Applicable' }).Count

# Score calculation (simple percentage of compliant checks out of applicable/non-error checks)
$ApplicableChecks = $TotalChecks - $ErrorChecks - $NotApplicableChecks
$Score = 0
if ($ApplicableChecks -gt 0) {
    $Score = [Math]::Round(($CompliantChecks / $ApplicableChecks) * 100)
}

Write-Host "`nAssessment Summary:" -ForegroundColor Cyan
Write-Host " Total Checks Performed: $TotalChecks"
Write-Host " Compliant:            $CompliantChecks" -ForegroundColor Green
Write-Host " Non-Compliant:        $NonCompliantChecks" -ForegroundColor $(if ($NonCompliantChecks -gt 0) { 'Red' } else { 'Green' })
Write-Host " Not Applicable:       $NotApplicableChecks" -ForegroundColor Gray
Write-Host " Errors:               $ErrorChecks" -ForegroundColor $(if ($ErrorChecks -gt 0) { 'Magenta' } else { 'Gray' })
Write-Host "---------------------------"
Write-Host " Overall Compliance Score: $Score%" -ForegroundColor $(if ($Score -lt 50) { 'Red' } elseif ($Score -lt 80) { 'Yellow' } else { 'Green' })

# Export Results to CSV
Write-Host "`nExporting assessment results to: $CsvOutputPath"
try {
    # Ensure output directory exists
    $OutputDirectory = Split-Path -Path $CsvOutputPath -Parent
    if ($OutputDirectory -and (-not (Test-Path -Path $OutputDirectory -PathType Container))) {
        Write-Host "Creating output directory: $OutputDirectory"
        New-Item -Path $OutputDirectory -ItemType Directory -Force | Out-Null
    }

    # Select the properties for the CSV in desired order
    $AssessmentResults | Select-Object CheckName, Status, Severity, Finding, Recommendation | Export-Csv -Path $CsvOutputPath -NoTypeInformation -Encoding UTF8

    Write-Host "Successfully exported assessment report to $CsvOutputPath" -ForegroundColor Green
}
catch {
    Write-Error "Failed to export assessment results to CSV. Error: $($_.Exception.Message)"
}

Write-Host "Assessment script finished."